#!/usr/bin/perl -w
#
# Copyright Felixalacampagne - September 2023 and G. Westcott - February 2013
#
# This code is distributed under the GNU General Public License v2 (GPLv2) .
#
#   For extended help information run
#         tv_grab_uk_sky_api  --info  TBD
#
# Get full channel list (overwrites tv_grab_uk_sky_api.conf.json)
#  tv_grab_uk_sky_api --configure
#
# Get tomorrows programes
#  tv_grab_uk_sky_api --days 1 --offset 1 --output test_tomorrow.xml
#
# 14-Sep-2023 More or less ready to integrate with XMLTV for writing the XML data
# 18-Sep-2023 Somewhat integrated into XMLTV project
# 23-Sep-2023 Working version

use strict;
use v5.10;

use JSON;
use Data::Dumper;
use DateTime;
use Encode;
use DateTime::Format::XSD; # cpanm DateTime::Format::XSD
use DateTime::TimeZone;
use DateTime;
use LWP::UserAgent;
use HTTP::Cookies;
use XMLTV;
use XMLTV::Options qw/ParseOptions/;
use XMLTV::Configure::Writer;
use File::Path;
use File::Spec;

################
####
#### WARNING: the --outfile option causes ALL stdout output to be sent to the specified file, not
####          just the XMLTV xml, and there is apparently no way to specify the output
####          file for XMLTV::write_data
####          Logging must be done using STDERR!!!!
####
################

# Init stuff using XMLTV copied from tv_grab_uk_tvguide
my $grabber_name="tvguide4xmltv";
my $grabber_version="0.0.2.0";

use XMLTV::Usage <<END;
tv_grab_uk_sky_api: Get UK Freesat television listings in XMLTV format
Version: $XMLTV::VERSION
To configure: $0 --configure [--config-file FILE]
To grab listings: $0 [--config-file FILE] [--output FILE] [--offset DAYS] [--days DAYS]
To list available channels: $0 --list-channels [--output FILE]
END

my $VERSION			= "$XMLTV::VERSION";
my $GRABBER_NAME		= 'tv_grab_uk_sky_api';
my $GRABBER_DESC		= 'UK - SKY TV Guide API (sky.co.uk)';
my $GRABBER_URL			= 'http://wiki.xmltv.org/index.php/XMLTVProject';
my $SOURCE_NAME			= 'SKY TV Guide API UK';
my $SOURCE_URL			= 'https://awk.epgsky.com/hawk/linear/';
# schedule/20230914/2006
my $SOURCE_PARAMS    = 'schedule/%s/%s'; 
my $SOURCE_CHANLIST   = 'services/4101/1';
#
my $generator_info_name	 = $GRABBER_NAME;
my $generator_info_url	 = $GRABBER_URL;
my $source_info_name	    = $SOURCE_NAME;
my $source_info_url		 = $SOURCE_URL;
my $source_info_params   = $SOURCE_PARAMS;
my $source_info_chanlist = $SOURCE_CHANLIST; 

my $grabberid = '2023-12-31.1007';
my $cachedir = '.xmltv';

# Must be done before ParseOptions so it is accessible to fetch_channels.
my $ua = initialise_ua();

# ------------------------------------------------------------------------------------------------------------------------------------- #
# Use XMLTV::Options::ParseOptions to parse the options and take care of the basic capabilities that a tv_grabber should have
our ($opt, $conf) = ParseOptions({
			grabber_name		=> $GRABBER_NAME,
			capabilities		=> [qw/baseline manualconfig apiconfig cache tkconfig/],		# apiconfig is needed for --list-channels (bug)
			stage_sub			=> \&config_stage,
			listchannels_sub	=> \&fetch_channels,
			version				=> $VERSION,
			description			=> $GRABBER_DESC,
			extra_options		=> [qw/method:i makeignorelist:s useignorelist:s usage test:i/], # TODO: What is this?
});
 
usage(1) if $opt->{usage};


initFromConf($conf, $opt);

# arrays used to create the XMLTV output
my @programmes = ();
my @channels = ();

# map of the required channels and the mapping from tvg to xmltv ids. Map is
# keyed on the TVG channel ID.
# This map will initially be generated by extractChannels for a configuration run and saved
# as a config file (JSON format) which can be edited to remove unwanted channels, change channel
# xmltvids and duplicate listings etc.
my %mapchannelhash;
my $channelpath = getChannelfile($conf->{channeldir}->[0]);
my $mapref = loadChannelList($channelpath);
%mapchannelhash = %$mapref;
# print Dumper \%mapchannelhash;

my $offset = 0;
my $days = 1;
if (($opt->{offset} > 0) && ($opt->{offset} < 7))
{
   $offset = $opt->{offset};
}

if (($opt->{days} > 1) && ($opt->{days} < 7))
{
   $days = $opt->{days};
}

# SKY api takes a list of channels but will putting ALL the channels into the list cause
# problems with the website? It is the most compatible with the TVGuide way as the returned day
# list will contain all required programmes just like for TVGUide. Otherwise will need to grab
# each channel one by one and maybe merge into a single list. NB. There are 46 channels in my normal list.
# Appears that the max no. of channels that can be requested in one go is 20.
# 
# The keys of mapchannelhash provide the guide ids. Must pass a ref to the array to getTVGForOffset
#
# getTVGForOffset will return  a json array of the items returned by the site produced by concatenating the
# the site reponses and wrapping in json array syntax, eg.
# { "mergedschedule" : [
# { "date": "20240102", "schedule": [ { "events": [ {prog1}, {prog2}...], "sid":"chanid1" }, { "events": [ {prog1}, {prog2}...], "sid":"chanid2" },...] }
# ,
# ...
# ] }
#
# Not sure if the "mergedschedule" : bit is really required, should be possible to just surround with '[' and ']' and insert ',' between the blocks from
# the website...
my @chanarry = keys %mapchannelhash;

for(my $day = $offset; $day < $days+$offset; $day++)
{
   logger("Grabbing programmes for day: %s\n", getStartTime($day));

   my $json = getTVGForOffset($day, \@chanarry);
   my $tvg = decode_json($json);

   
   # tvg is an ARRAY ref os @{$arr_ref} is the same as @arr
   # tvg is an array of date/schedule/events hashes but what is really needed is
   # an hash with sid as key and an array of programmes as value.
   # So now need to extract the 'events' arrays from all blocks into @programmes
   # This needs to work differently to the TVGuide as there are now only required channels
   # in the list and the programmes are listed by channel
   # So
   # for each tvg item
   #   for each schedule item
   #      for each events item
   #         extract the event item into a program for schedule itme>sid


   for my $block (@{$tvg}) 
   {
      logger("block date: %s\n", $block->{date});
      for my $sched (@{$block->{schedule}})
      {
         print Dumper %{$sched};
         logger("Processing events for sid: %s\n", $sched->{sid});
         for my $event (@{$sched->{events}})
         {
            my $startunix = $event->{st};
            my $endunix = $startunix + $event->{d};
            logger("Processing event: %s %d %d %d\n", $event->{t}, $startunix, $event->{d}, $endunix);
            
            # One Show startime displays as 19:00 whether localtime or gmtime is used even with 'TZ=Europe/Brussels'
            # eg. using gmtime
            # Processing event: The One Show 1704308400 1800 1704310200
            # Processing event:         Wed Jan  3 19:00:00 2024 Wed Jan  3 19:30:00 2024
            # Unix time should be GMT by definition so need a way to convert the GMT time to local (CET) time
            # Or does the rest of the processing work when the XMLTV times use GMT?
            # Yet more weird Perl behaviour: TZ unset           - gmtime 19:00, localtime 20:00
            #                                TZ=Europe/Brussels - gmtime 19:00, localtime 19:00
            #my $starttime = gmtime( $event->{st});
            #my $endtime = gmtime($endunix);
            
            my $startdt = DateTime->from_epoch(epoch => $startunix);
            my $enddt = DateTime->from_epoch(epoch => $endunix);

            # DateTime gives UTC when no timezone is applied, including when TZ is set
            logger("  UTC start:%s end:%s\n", $startdt->strftime("%Y%m%d %H%M%S %z"), $enddt->strftime("%Y%m%d %H%M%S %z"));

            #my $tz = DateTime::TimeZone->new( name => 'local' );
            #$dt = $dt->set_time_zone($tz);
            ## Original DateTime with timezone applied gives the appropriate offset time
            #logger("DateTime+TZ:  %s\n", $dt->strftime("%Y%m%d %H%M%S %z"));

            # DateTime with immediate timzone gives appropriate offset time
            my $startdttz = DateTime->from_epoch(epoch => $startunix, time_zone => 'local');
            my $enddttz = DateTime->from_epoch(epoch => $endunix, time_zone => 'local');
            logger("  CET start:%s end:%s\n", $startdttz->strftime("%Y%m%d %H%M%S %z"), $enddttz->strftime("%Y%m%d %H%M%S %z"));
         }

         # guideid is known. 
         # (@{$sched->{events}} contains the array of event for sid today
         # Need to find the channel map for sid to pass to extractProgrammesForChannel
         # eg. $mapchannelhash{$sched->{sid}} maybe?
         # extractProgrammesForChannel needs to take a 'simple' array of events to be mapped to an entry in @programmes

	 # NB This is unlikely to work as is!!!!
         my $chref = $mapchannelhash{$sched->{sid}} # $mapchannelhash{$keychmap};
         extractProgrammesForChannel($sched->{events}}, $chref, \@programmes);
      }
   }   
   exit;

   # To find an entry in the array of hashes with a given value use something like
   # my ($p) = first { $id == $_->{id} } @$people; (use List::Util qw(first);)
   # Searching an array of hashes like this is not performant when finding multiple different values.
   # More efficient to create a hash of hashes from the original array keyed on the search value.
   # This is what the magic below does. 
   my %epglookup = map { $_->{id} => $_ } @{$tvg};
   #print Dumper \%epglookup;
   
   for my $keychmap (keys %mapchannelhash)
   {
      my $chref = $mapchannelhash{$keychmap};
      extractProgrammesForChannel(\%epglookup, $chref, \@programmes);
   }
}

makeXMLTVChannels(\%mapchannelhash, \@channels);

# ------------------------------------------------------------------------------------------------------------------------------------- #
# Generate the XML
my $encoding = 'UTF-8';
my $credits = { 'generator-info-name' 	=> $generator_info_name,
				'generator-info-url' 	=> $generator_info_url,
				'source-info-name' 		=> $source_info_name,
				'source-info-url' 		=> $source_info_url };

# No need for write_data to filter anything as only the days/offset requested are fetched
my %w_args;
#$w_args{offset} = $offset ;
#$w_args{days}   = $days;
#$w_args{cutoff} = '000000';

# channels is expected to be a 'hashref' - no idea why or what the key should be but this seems to work/
my %channelshash = map { $_->{id} => $_ } @channels;
XMLTV::write_data([ $encoding, $credits, \%channelshash, \@programmes ], %w_args);

cleanCache();

# Finished!
exit(0);


######################################################
#####                                            #####
##### end of main                                #####
#####                                            #####
######################################################
sub initFromConf
{
   my ($conf, $opt) = @_;

   # any overrides?
   if (defined( $conf->{'generator-info-name'} ))	{ $generator_info_name 	= $conf->{'generator-info-name'}->[0]; }
   if (defined( $conf->{'generator-info-url'} ))	{ $generator_info_url  	= $conf->{'generator-info-url'}->[0]; }
   if (defined( $conf->{'source-info-name'} )) 	{ $source_info_name 	= $conf->{'source-info-name'}->[0]; }
   if (defined( $conf->{'source-info-url'} ))  	{ $source_info_url  	= $conf->{'source-info-url'}->[0]; }
   if (defined( $conf->{'$source-info-params'}))  	{ $source_info_params  	= $conf->{'source-info-params'}->[0]; }
   
   $cachedir = $conf->{cachedir}->[0];
   init_cachedir($cachedir);   
}

# init stuff based on/copied from tv_grab_uk_tvguide

# Callback given to ParseOptions for listing the channels.
# - invoked by --configure command line option
# Quite a bit of code from main is duplicated for this as I was expecting
# a simple flag to be set by the config routine. Can be refactored some other time.
# Oh boy was I wrong - it seems this function is expected to return a list of channels
# in XMLTV formatted XML. 
# The user is then presented with a list of channels and option to answer yes/no for each
# channel (or all). It is a very long list and selecting the channels in this way is very cumbersome. 
# The selected channels are saved in the 'tv_grab_uk_tvguide_api.conf'
# file in the '.xmltv' subsirectory, together with the channeldir and cachedir properties.
# These channel properties are the unmapped XMLTV ids which are lost when a different mapping is used.
# Updating the list once it is created is a rare event so not going to waste time trying to 
# create a way to edit via the grabber - far easier to use a text editor to remove unwanted items from the json list.
# TODO find a way to avoid the channel list prompt!
sub fetch_channels
{
   my ($conf, $opt) = @_;
   my $channelpath = getChannelfile($conf->{channeldir}->[0]);  
   
   initFromConf($conf, $opt);
   
   logger("fetch_channels: saving channel list to '%s'\n", $channelpath);
   
   my $json = getChannelList();
   my $tvg = decode_json($json);
   #print Dumper $tvg;

   my $epgref = $tvg->{services};


   
   my %epglookup = map { $_->{sid} => $_ } @{$epgref};   
   extractChannels(\%epglookup, \%mapchannelhash);
  
   saveChannelList($channelpath, \%mapchannelhash);   
   
   # The original returns a list of channels in XMLTV xml format. The user is then prompted
   # to determine which channels to download. The selected channels then appear in the .conf file 
   # in the .xmltv sub-dir. I'm not going to use this list so just return an empty 
   # list as a response. 
   my $result;
   my $writer = new XMLTV::Writer(OUTPUT => \$result, encoding => 'utf-8');
   $writer->start({'generator-info-name' => $generator_info_name});
   
   $writer->end();
   
   return $result;
}

# Callback given to ParseOptions for ????
sub config_stage {
	my( $stage, $conf ) = @_;
	die "Unknown stage $stage" if $stage ne "start";

	my $result;
	my $writer = new XMLTV::Configure::Writer( OUTPUT => \$result, encoding => 'utf-8' );
	$writer->start( { grabber => $GRABBER_NAME } );

	# the channel config location should default to the config directory but this does not appear 
	# to be exposed via a method anywhere unfortunately so must guess the value to use.
	# It appears to be a subdirectory of the script directory called '.xmltv'
	$writer->write_string({
			id => 'channeldir',
			title => [ [ 'Directory to store the channel configuration in', 'en' ] ],
			description => [
			 [ $GRABBER_NAME.' creates a file containing a list of channels available for download. Please specify where this list should be stored. ',
				 'en' ] ],
			default => get_default_configdir(),
	 });

	# This should be a sub-dir of whatever was chosen for the config dir.
	$writer->write_string({
			id => 'cachedir',
			title => [ [ 'Directory to store the cache in', 'en' ] ],
			description => [
			 [ $GRABBER_NAME.' uses a cache with files that it has already '.
				 'downloaded. Please specify where the cache should be stored. ',
				 'en' ] ],
			default => get_default_cachedir(),
	 });

	$writer->end( 'select-channels' );

	return $result;
}

sub get_default_dir {
   my $winhome = $ENV{HOMEDRIVE} . $ENV{HOMEPATH} if defined( $ENV{HOMEDRIVE} ) and defined( $ENV{HOMEPATH} );
   my $home = $ENV{HOME} || $winhome || ".";
   return $home;
}

sub get_default_configdir
{
    return '.xmltv';
}

sub get_default_cachedir 
{
    return File::Spec->catdir(get_default_configdir(), 'cache');
}

sub init_cachedir 
{
    my( $path ) = @_;
    if( not -d $path ) {
		mkpath( $path ) or die "Failed to create cache-directory $path: $@";
    }
}

sub initialise_ua {
	my $cookies = HTTP::Cookies->new;
	#my $ua = LWP::UserAgent->new(keep_alive => 1);
	my $ua = LWP::UserAgent->new;
	# Cookies
	$ua->cookie_jar($cookies);
	# Define user agent type
	$ua->agent('Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US)');
	# Define timouts
	$ua->timeout(240);
	# Use proxy if set in http_proxy etc.
	$ua->env_proxy;
	return $ua;
}

# end init stuff from tv_grab_uk_tvguide

sub makeXMLTVChannels
{
my($chanmaphashref, $xmltvchanarrayref) = @_;  

# $channels->{$channel_id} = { 'id'=> $xmlchannel_id , 'display-name' => [[ encode('utf-8', $channelname), 'en' ]]  };

   for my $key (keys %{$chanmaphashref})
   {
      my $chanref = $chanmaphashref->{$key};
      
      my $idsref = $chanref->{'xmltvIds'};
      foreach my $xidref (@{$idsref})
      {      
         my $id = $xidref->{'xmltv-id'};
         my $name = $xidref->{'display-name'};
         # printf "makeXMLTVChannels: id:%s, name:%s\n", $id, $name;
         my %chan = ( 'id' => $id, 'display-name' => [[ encode('utf-8', $name), 'en' ]] );
         push(@{$xmltvchanarrayref}, \%chan);
      }
   }
}


# Save the channel list as an array, maybe it can be sorted more easily and it's simpler to edit
sub loadChannelList
{
my($file) = @_;
#my $chanarrayref = read_json ($file);
my $json = loadtext($file);
my $chanarrayref = decode_json($json);

my %chanmap = map { $_->{'guide-id'} => $_ } @{$chanarrayref};
   return \%chanmap;
}

sub saveChannelList
{
my($file, $chanmaphashref) = @_;
my @chanarray;
   for my $key (keys %{$chanmaphashref})
   {
      push(@chanarray, $chanmaphashref->{$key});
   }

   my @chanarraysorted = sort {$a->{'display-name'} cmp $b->{'display-name'} } @chanarray;

   # canonical means the fields appear in the same order for each xmltv channel id which is easier to edit
   my $json = to_json(\@chanarraysorted, {utf8 => 1, pretty => 1, canonical => 1});
   savetext($file, $json);
}

sub extractChannels
{
my($epghashref, $chanmaphashref) = @_;

#    "services": [
#        {
#            "adult": false,
#            "avail": [
#                "BROADCAST"
#            ],
#            "c": "101",
#            "local": false,
#            "sf": "SD",
#            "sg": 3,
#            "sid": "1006",
#            "t": "BBC One",
#            "xsg": 3
#        },
# services->sid, services->c, services->t
# print Dumper $epghashref;
# NB: names with '-' must be quoted when literals are used in the code
   # Apparently no way to directly iterate over the values of a hash, must
   # get an array of the keys and extract the value using the key
   for my $keyepg (keys %{$epghashref})
   {
      my $epgref = $epghashref->{$keyepg};
      printf "epg:%d title:%s sid:%s\n", $epgref->{c}, $epgref->{t}, $epgref->{sid};
      my %xmltvid = ();
      $xmltvid{'xmltv-id'} =  $epgref->{c} . ".sky.co.uk";
      $xmltvid{'display-name'} = $epgref->{t};
      my @xmltvids = ( %xmltvid );
      $chanmaphashref->{$epgref->{sid}} = {
         'guide-id' => $epgref->{sid},
         'display-name' => $epgref->{t},
         'xmltvIds' => [  \%xmltvid ]
      }
   }
   # print Dumper $chanmaphashref;
}

# TVG date format is:
# 'start_at' => '2023-09-13T18:30:00.000Z',
sub parseTVGDate
{
   my($tvgdate) = @_;
   # YYYY-MM-DD"T"HH:MI:SS(Z|[+-]zh:zm)
   my $dt = DateTime::Format::XSD->parse_datetime($tvgdate);
   my $tz = DateTime::TimeZone->new( name => 'local' );
   $dt = $dt->set_time_zone($tz);
   # logger( "parseTVGDate: tvg:%s xmltv:%s\n", $tvgdate, $dt->strftime("%Y%m%d%H%M%S %z"));
   return $dt;
}

sub extractProgram
{
   my($progref, $chnhashref, $progarray) = @_;
   my $chnid = $chnhashref->{'xmltv-id'};
   my %prog = ();  # This is a single program hash to be added to the $progarray
   my $title = $progref->{title};
   my $desc = $progref->{summary_short};
   
   # Try to avoid XMLTV warning 'not writing empty content for desc '
   $desc =~ s/^\s+//;
   $desc =~ s/\s+$//;

   # Encoding the data in Perl structure compatible wit current tvguide
   $prog{'channel'} = $chnid;
   $prog{'title'} = [[ encode('utf-8', $title), 'en' ]];
   $prog{'start'} = parseTVGDate($progref->{start_at})->strftime("%Y%m%d%H%M%S %z");
   $prog{'stop'} = parseTVGDate($progref->{end_at})->strftime("%Y%m%d%H%M%S %z");
   # $prog{'category'}
   
   if (length $desc) 
   {
      # Only add desc if there is something present. 
      # Might end up being better to add something if the missing desc causes 
      # issues further down the processing chain, make dpulicate the title.
      # $desc = "DESCRIPTION NOT PRESENT";
      $prog{'desc'} = [[ encode('utf-8', $desc), 'en' ]];
   }   
   

   $prog{'title'} = [[ encode('utf-8', $progref->{title}), 'en' ]];
   # $prog{'sub-title'} = [[ encode('utf-8', $showeptitle->as_text), 'en' ]];

   # printf "start:%s title:%s\n", $progref->{start_at}, $progref->{title};
   if($progref->{type} eq 'episode') # can be 'movie'
   {
      # NB. No episode title info available from tvguide.co.uk AFAICS
      #'meta' => {
      #    'season' => '4',
      #    'episode_total' => '24',
      #    'episode' => '8',
      #    'attributes' => []
      #  },
      my $metahash = $progref->{meta};
      
      my $season;
      my $epnumber;
      my $eptotal;
      my ($showpxx, $showpof) = ('', '');
      if(exists $metahash->{season} )
      {
         # FORK ME! no atoi equivalent, but Perl spews alarming messages if numeric is followed by alphas
         # $season = $metahash->{season};
         my ($num) = $metahash->{season}=~ m/(\d+)/;
         $season = $num;
      }
      if(exists $metahash->{episode_total})
      {
          #$eptotal = $metahash->{episode_total};
         my ($num) = $metahash->{episode_total}=~ m/(\d+)/;
         $eptotal = $num;          
      }
      
      if(exists $metahash->{episode})
      {
         # $epnumber = $metahash->{episode};
         my ($num) = $metahash->{episode}=~ m/(\d+)/;
         $epnumber = $num;          
      }   

      my $showepnum = make_ns_epnum($season, $epnumber, $eptotal, $showpxx, $showpof);
      if ($showepnum && $showepnum ne '...' && $showepnum ne '..') 
      {
         $prog{'episode-num'} = [[ $showepnum, 'xmltv_ns' ]];
      }      
   } 
   push(@{$progarray}, \%prog);      
}

sub extractProgrammesForChannel
{
my($epghashref, $chnhashref, $progarray) = @_;	
my $guideId = $chnhashref->{'guide-id'};
   my $idsref = $chnhashref->{'xmltvIds'};
   
   foreach my $chref (@{$idsref})
   {
      my $chnname = $chref->{'display-name'};

      # print "extractProgrammesForChannel: extracting $chnname\n";
       
      my $epgref = $epghashref->{$guideId}; # %{$epghashref}{$epg}; # This is a hash ref
      my $schedref = $epgref->{schedules}; # This is a array ref

      foreach my $progref (@{$schedref})
      {
         extractProgram($progref, $chref, $progarray);
      }
   }
}

sub getStartTime
{
   my($offdays) = @_;    
   my $dt = DateTime->now( time_zone => 'Europe/London' );

   $dt = $dt->set_hour(6)->set_minute(0)->set_second(0);
   $dt = $dt->add(days => $offdays);
   $dt = $dt->set_time_zone('UTC');
   logger("getStartTime: offset:%d starttime %s\n", $offdays, $dt->rfc3339);
   return $dt;
}

sub formatUrlDateTime
{
   my($dt) = @_;  
   my $msnTZ = "%3A00%3A00.000Z"; # mins, secs, nanos are always 0, assume TZ is always UTC
   my $fmtd = sprintf("%sT%02d%s", $dt->ymd, $dt->hour, $msnTZ); 
   return $fmtd;
}

# Returns date formatted as YYYYMMDD
# NB date->ymd returns YYYY-MM-DD
sub formatUrlDate
{
   my($dt) = @_;  
   my $fmtd = $dt->ymd(''); # sprintf("%s%02s%02s", $dt->year, $dt->month, $dt->day);
   return $fmtd;
}


sub getChannelList
{
my $url=$source_info_url . $source_info_chanlist; 

   logger( "getChannelList: url=%s\n", $url);

   my @params;
   push(@params, content_type => 'application/json');
   #push(@params, token => $sd_json_token) unless $path eq 'token';
   #push(@params, content => encode_json($content)) if defined $content;
   my $response = "";
   $response = loadtext("rawchanlist.json");
   if($response ne "")
   {
      logger( "getChannelList: using cached channel list\n");
      return $response;
   }
   
   $response = $ua->get($url, @params);
   if($response->is_success()) {
      my $json = $response->decoded_content();
      savetext("rawchanlist.json", $json);
      return $json;
   }   
   warn "getChannelList: request returned failure\n";
   return "";  
}

sub getTVGForOffset
{
my($offset, $chanarryref) = @_; 
# chanarryref is an ARRAY ref so @{$arr_ref} is the same as @arr
my @jsons;
my $baseurl=$source_info_url . $source_info_params; 
my $startdate = getStartTime($offset);

# NB The add method actually increments $startdate and also increments variables created by simple assigment, 
# eg. for 'my $cachedate = $startdate;' the value of $cachedate will be incremented by '$startdate->add(days => 1)
# my $cachedate = $startdate->clone();
# my $starttime = formatUrlDateTime($startdate);
# my $endtime = formatUrlDateTime($startdate->add(days => 1));
my $urldate = formatUrlDate($startdate);
my $url;
my $chansrequested=0;
my $chanperrequest=20;
my $chantotal= scalar @{$chanarryref};
my $json;
   logger("getTVGForOffset: startdate:%s\n", $startdate->ymd);
   my $cached = loadFromCache($startdate);
   if( length $cached )
   {
      logger("getTVGForOffset: loaded data for offset %s from cache\n", $offset);
      return $cached;
   }

   logger("getTVGForOffset: requesting %d channels in goups of %d\n", $chantotal, $chanperrequest);
   while($chansrequested < $chantotal)
   {
      my $si = $chansrequested;
      my $ei = $si + $chanperrequest - 1;
      if($ei >= $chantotal)
      {
         $ei = $chantotal - 1;
      }
      
      my $chanparm = join(',', @{$chanarryref}[$si..$ei]);
      $url=sprintf($baseurl, $urldate, $chanparm);
      logger( "getTVGForOffset: url=%s\n", $url);
   
      my @params;
      push(@params, content_type => 'application/json');
      #push(@params, token => $sd_json_token) unless $path eq 'token';
      #push(@params, content => encode_json($content)) if defined $content;
   
      my $response = $ua->get($url, @params);
      if( ! $response->is_success()) {
   
         #logger( "getTVGForOffset: reponse:\n%s\n", $json);
         warn "getTVGForOffset: request returned failure for url: $url\n";
         return "";
   
      }  
      $json = $response->decoded_content();
      push(@jsons, $json); 
      $chansrequested = $ei + 1;   
   }

   $json = "[ " . join(',', @jsons) . ' ]';
   saveToCache($startdate, $json);
   
   return $json;   
}

# Copied from original tv_grab_uk_tvguide

sub make_ns_epnum {
   # Convert an episode number to its xmltv_ns compatible - i.e. reset the base to zero
   # Input = series number, episode number, total episodes,  part number, total parts,
   #  e.g. "1, 3, 6, 2, 4" >> "0.2/6.1/4",    "3, 4" >> "2.3."
   #
   my ($s, $e, $e_of, $p, $p_of) = @_;
   #	debug Dumper(@_);
   
   # "Part x of x" may contain integers or words (e.g. "Part 1 of 2", or "Part one")
   $p = text_to_num($p) if defined $p;
   $p_of = text_to_num($p_of) if defined $p_of;
   

   # re-base the series/episode/part numbers
   $s-- if (defined $s && $s > 0);
   $e-- if (defined $e && $e > 0);
   $p-- if (defined $p && $p && $p=~/^\d+$/ && $p > 0);
   
   # make the xmltv_ns compliant episode-num
   my $episode_ns = '';
   $episode_ns .= $s if defined $s;
   $episode_ns .= '.';
   $episode_ns .= $e if defined $e;
   $episode_ns .= '/'.$e_of if defined $e_of;
   $episode_ns .= '.';
   $episode_ns .= $p if $p;
   $episode_ns .= '/'.$p_of if $p_of;
   
   #debug "--$episode_ns--";
   return $episode_ns;
}

sub text_to_num {
   # Convert a word number to int e.g. 'one' >> '1'
   #
   my ($text) = @_;
   if ($text !~ /^[+-]?\d+$/) {	# standard test for an int
   	my %nums = (one => 1, two => 2, three => 3, four => 4, five => 5, six => 6, seven => 7, eight => 8, nine => 9);
   	return $nums{$text} if exists $nums{$text};
   }
   return $text
}

sub getChannelfile
{
   my ($channeldir) = @_;
   my $channelfile= $generator_info_name . '.conf.json';
   # my $channeldir = '.xmltv';  # $conf->{cachedir}->[0];
   my $channelpath = $channelfile;
   if (length $channeldir)
   {
      $channelpath = File::Spec->catdir($channeldir, $channelfile); 
   } 
   return $channelpath;   
}

sub loadtext 
{
   my ($file) = @_;
   open my $fh, '<', $file or die "Can't open file $file: $!";
     
   binmode $fh, ":encoding(utf-8)";   
   my $file_content;
   
   read $fh, $file_content, -s $fh;
   return $file_content
}

sub savetext
{
my ($path, $data) = @_;

   unlink "$path";
   if(open(my $output, ">", $path) )
   {
      binmode $output, ":unix:encoding(UTF-8)";
      print $output $data;
      close($output);
   }
   else
   {
      warn "Failed to save file: " . $path . " : " . $! . "\n";
   }
}


sub getCacheDir
{
   return $cachedir;
}

sub getCacheName
{
   my($dt) = @_;
   return sprintf("skyapi_%s.json", $dt->ymd(''));
}

sub getCachePath
{
   my($dt) = @_;   
   return File::Spec->catdir(getCacheDir(), getCacheName($dt));
}

sub loadFromCache
{
   my($dt) = @_;
   my $data = "";
   my $cachename = getCachePath($dt);
   
   if( -f $cachename)
   {
      logger("loadFromCache: loading cache file: %s\n", $cachename);
      $data = loadtext($cachename);
   }
   else
   {
      logger("loadFromCache: cache file not found: %s\n", $cachename);
   }
   
   return $data;
}

sub saveToCache
{
   my($dt, $data) = @_;
   my $cachename = getCachePath($dt);
   savetext($cachename, $data);
}

sub cleanCache
{
   my $oldest = getCacheName(getStartTime(0));
   my $dir = getCacheDir();
   my $dh;
   opendir $dh, $dir or die "Couldn't open dir '$dir': $!";
   my @files = grep { !/^\.\.?$/ } readdir $dh;
   closedir $dh;

   # print "Found @files in $curdir\n";
   foreach my $file (@files)
   {
      if( $file lt $oldest )
      {
         logger("cleanCache: removing expired cache file: %s\n", $file);
         my $fullfile = File::Spec->catdir($dir, $file);
         unlink $fullfile;
      }
   }   
}

sub logger
{
   my ($msg) = @_;

   # Log to STDERR because ALL stdout output is redirected to the 'outfile' rather than only the
   # output from XMLTV::write_data
   printf STDERR @_;
}

# #############################################################################

__END__

=pod

=head1 NAME

B<tv_grab_uk_tvguide_api> - Grab TV listings for UK from the TVGuide API.

=head1 SYNOPSIS

tv_grab_uk_tvguide_api --usage

tv_grab_uk_tvguide_api --version

tv_grab_uk_tvguide_api --configure [--config-file FILE] [--gui OPTION] [--method N]
                   [--makeignorelist FILE] [--useignorelist FILE] [--debug]

tv_grab_uk_tvguide_api [--config-file FILE] [--output FILE] [--days N]
                   [--offset N] [--nodetailspage]  [--legacychannels]
                   [--quiet] [--debug]

tv_grab_uk_tvguide_api --list-channels [--output FILE] [--method N] [--debug]
                       WARNING:  will overwrite the existing channel list file
                       
=head1 DESCRIPTION

Output TV listings in XMLTV format for many channels available in UK.
The data come from the API provided by tvguide.co.uk

First you must run B<tv_grab_uk_tvguide --configure> to create a list of available channels.
This list can then be edited using a text editor to remove unwanted channels. The list
is in JSON format which is pretty simple to figure out. The file is called
'tv_grab_uk_tvguide_api.conf.json' and located by default in the '.xmltv' sub-directory
of the script/exe directory

Then running B<tv_grab_uk_tvguide_api> with no arguments will get programme listings 
in XML format for the channels you chose, for available days including today.

=head1 OPTIONS

B<--configure> Prompt for which channels to fetch the schedule for, 
and write the configuration file.

B<--config-file FILE> Set the name of the configuration file, the default 
is B<~/.xmltv/tv_grab_uk_tvguide_api.conf>.  This is the file written by
--configure and read when grabbing.

B<--days N> Grab N days. The default is 5 days.

B<--offset N> Start N days in the future.  The default is to start
from today.

B<--output FILE> Write to FILE rather than standard output.

B<--list-channels> Re-create the default full available channel list file. WARNING: this will overwrite
an existing channel list file containing user modifications.

B<--version> Show the version of the grabber.

B<--usage> Print a help message and exit.

=head1 INSTALLATION

The file F<tv_grab_uk_tvguide_api.conf.json> has two purposes;

1) map the channel ids used by the site into something more meaningful to your PVR, eg.

   {
      "display-name" : "4Music",
      "guide-id" : "a4539d2a-1cee-52f5-a00e-d68835ce3e9f",
      "xmltvIds" : [
         { "display-name" : "4Music", "xmltv-id" : "TVGC4M" }
      ]
   }

will use TVGC4M as the XMLTV channel ID for prgrammes with a guide id of "a4539d2a-1cee-52f5-a00e-d68835ce3e9f".

2) create multiple listings with different xmltv IDs for a single guide ID, eg. 

   {
      "display-name" : "4Music",
      "guide-id" : "a4539d2a-1cee-52f5-a00e-d68835ce3e9f",
      "xmltvIds" : [
         { "display-name" : "4Music", "xmltv-id" : "TVGC4M" },
         { "display-name" : "4MusicHD", "xmltv-id" : "TVGC4M_HD" }
      ]
   }

This is useful when the PVR has channels for which there is no separate listing in the guide but
for which the programmes are identical to a listing which is ihe guide, eg. 'BBC One' and 'BBC One London HD'.

=head1 ERROR HANDLING

If the grabber fails then ther might be a message to help determine the cause.

=head1 ENVIRONMENT VARIABLES

TZ - should be set to the timezone to be used for the XMLTV listings, eg 
set TZ=Europe/Brussels

=head1 SUPPORTED CHANNELS

For information on supported channels, see http://tvguide.co.uk/

=head1 XMLTV VALIDATION

B<tv_validate_grabber> may report an error similar to:

      "Line 5 Invalid channel-id BBC 1"

This is a because ValidateFile.pm insists the channel-id adheres to RFC2838 despite the xmltv.dtd only saying "preferably" not "SHOULD".
(Having channel ids of the form "bbc1.bbc.co.uk" will be rejected by many PVRs since they require the data to match their own list.)

It may also report:

      "tv_sort failed on the concatenated data. Probably due to overlapping data between days."

Both these errors can be ignored.

=head1 DISCLAIMER

The TVGuide website's license for these data does not allow non-personal use.

Certainly, any commercial use of listings data obtained by using this grabber will breach copyright law, but if you are just using the data for your own personal use then you are probably fine.

By using this grabber you aver you are using the listings data for your own personal use only and you absolve the author(s) from any liability under copyright law or otherwise.

=head1 AUTHOR

Felixalacampagne/ Geoff Westcott. This documentation and parts of the code
based on various other tv_grabbers from the XMLTV-project.

=head1 SEE ALSO

L<xmltv(5)>.

=cut


To Do
=====

1.  Backup existing json file before creating a new one.
2.  Use --configfile for the channel list input - Maybe put the channel list pathname in the
    xmltv config so a different file can be used via a different xmltv config file.
3.  Suppress the 'select channels' prompt at end of --configure
4.  Refactor initialization to avoid duplication in fetch_channels 
